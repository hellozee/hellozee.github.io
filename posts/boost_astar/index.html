<!doctype html>

<html lang="en">

<head>
  <title>A Nerd&#39;s Tale</title>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="description" content="The HTML5 Herald" />
  <meta name="author" content="hellozee" />
  <meta name="generator" content="Hugo 0.40.1" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/normalize/7.0.0/normalize.min.css" />
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css" />
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto+Slab|Ruda" />
  <link rel="stylesheet" type="text/css" href="https://hellozee.github.io/css/styles.css" />
</head>

<body>
  <div id="container">
    <header>
      <h1>
                <a href="https://hellozee.github.io/">A Nerd&rsquo;s Tale</a>
            </h1>

      <ul id="social-media">
        
        <li><a href="https://twitter.com/hellozee54"><i class="fa fa-twitter fa-lg" aria-hidden="true"></i></a></li>
         
        <li><a href="https://www.linkedin.com/in/mkuntal"><i class="fa fa-linkedin fa-lg" aria-hidden="true"></i></a></li>
         
        <li><a href="https://github.com/hellozee"><i class="fa fa-github fa-lg" aria-hidden="true"></i></a></li>
         
        <li><a href="https://gitlab.com/hellozee"><i class="fa fa-gitlab fa-lg" aria-hidden="true"></i></a></li>
          
      </ul>
      
      <p><em>A place where I can shout</em></p>
      
    </header>

    
<nav>
    <ul>
        
        <li>
            <a class="" href="https://hellozee.github.io/">
                <i class="fa-li fa  fa-lg"></i><span>Home</span>
            </a>
        </li>
        
        <li>
            <a class="" href="https://hellozee.github.io/posts/">
                <i class="fa-li fa  fa-lg"></i><span>Blog</span>
            </a>
        </li>
        
        <li>
            <a class="" href="https://hellozee.github.io/about/">
                <i class="fa-li fa  fa-lg"></i><span>About</span>
            </a>
        </li>
        
    </ul>
</nav>

    <main>




<article>

    <h1>Dissecting boost::astar_search</h1>

    
        <aside>
    <ul>
        <li>
            <time class="post-date" datetime="2019-05-26T04:43:18&#43;05:30">May 26, 2019</time>
        </li>
        
        
        <li>
            Categories: 
            <em>
                
                    
                    <a href="https://hellozee.github.io/categories/krita/">krita</a>
                
            </em>
        </li>
        

        
        <li>
            <em>
                
                    
                    <a href="https://hellozee.github.io/tags/krita/">#krita</a>
                
                    , 
                    <a href="https://hellozee.github.io/tags/gsoc/">#gsoc</a>
                
                    , 
                    <a href="https://hellozee.github.io/tags/open-source/">#open-source</a>
                
                    , 
                    <a href="https://hellozee.github.io/tags/kde/">#kde</a>
                
                    , 
                    <a href="https://hellozee.github.io/tags/boost/">#boost</a>
                
                    , 
                    <a href="https://hellozee.github.io/tags/cpp/">#cpp</a>
                
            </em>
        </li>
        

        <li>7 min read</li>
    </ul>
</aside>
    

    

<p>Right now, I am having a hard time understanding BGL&rsquo;s (the Boost Graph Library) template spaghetti, so decided to write a blogpost while I decipher it, one at a time, documenting the whole thing along the way.</p>

<h1 id="day-1">Day 1</h1>

<p><a href="https://invent.kde.org/dkazakov">Dmitry</a> told me that I can most likely reuse the <code>KisLazyFillGraph</code> class in my astar search instead of trying to wrap <code>KisPaintDevice</code> to boost::graph since the former was already wrapped for the purpose of utilizing the graph algorithms that boost provide. Most of the code didn&rsquo;t make any sense to me, but I will be optimistic and assume that by the end of the month, I would get hold of most of it. So let me ignore that for the moment will come back as I make some progress.</p>

<p><strong>First Stop:</strong> The <a href="https://www.boost.org/doc/libs/1_70_0/libs/graph/doc/astar_search.html">documentation</a> of <code>boost::astar_search</code> of course. There are 3 kinds of <code>boost::astar_search</code> here, though I am yet to take a look at the source code, but I bet 2 of them just wrap the first one in some way. On a closer look, they have a lot of parameters, enough to scare any idiot like me. The versions which don&rsquo;t initialize the maps (wild guess from the _no_init suffix) use an <code>IncidenceGraph</code> whereas the other versions use <code>VertexListGraph</code>.  Looking at my heuristic function, I will probably need to use a <code>VertexListGraph</code>, since I need three points to calculate the cost, the previous point, the final point and the point in question.</p>

<p>Time to choose one of the interfaces to proceed further in the dissection, I am going with this one as the first choice, will try other if this didn&rsquo;t work, reasons? use <code>VertexListGraph</code>, non named parameters and simpler than its sibling who also satisfies the first 2 reasons and I don&rsquo;t think I would need <code>VertexIndexMap</code> or <code>ColorMap</code> but I might be wrong too.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#66d9ef">template</span> <span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> VertexListGraph, <span style="color:#66d9ef">typename</span> AStarHeuristic,
          <span style="color:#66d9ef">typename</span> AStarVisitor, <span style="color:#66d9ef">typename</span> PredecessorMap,
          <span style="color:#66d9ef">typename</span> CostMap, <span style="color:#66d9ef">typename</span> DistanceMap,
          <span style="color:#66d9ef">typename</span> WeightMap,
          <span style="color:#66d9ef">typename</span> CompareFunction, <span style="color:#66d9ef">typename</span> CombineFunction,
          <span style="color:#66d9ef">typename</span> CostInf, <span style="color:#66d9ef">typename</span> CostZero<span style="color:#f92672">&gt;</span>
<span style="color:#66d9ef">inline</span> <span style="color:#66d9ef">void</span>
astar_search_tree
  (<span style="color:#66d9ef">const</span> VertexListGraph <span style="color:#f92672">&amp;</span>g,
   <span style="color:#66d9ef">typename</span> graph_traits<span style="color:#f92672">&lt;</span>VertexListGraph<span style="color:#f92672">&gt;::</span>vertex_descriptor s,
   AStarHeuristic h, AStarVisitor vis,
   PredecessorMap predecessor, CostMap cost,
   DistanceMap distance, WeightMap weight,
   CompareFunction compare, CombineFunction combine,
   CostInf inf, CostZero zero);
</code></pre></div>
<p>Parameters which matter:</p>

<ul>
<li><code>AStarHeuristic</code>: Interface for the heuristic function</li>
<li><code>AStarVisitor</code>: Interface for the visitor</li>
<li><code>PredecessorMap</code>: Vertex to Vertex mapping.</li>
<li><code>CostMap</code> : Cost calculated at each vertex by the heuristic function?  I guess</li>
<li><code>DistanceMap</code> : Vertex to Distance mapping.</li>
<li><code>WeightMap</code>: Seems similar to DistanceMap, to be fair I can&rsquo;t tell.</li>
<li><code>CompareFunction</code> : No idea, there is no page describing it.</li>
<li><code>CombineFunction</code> : Same for this one.</li>
<li><code>CostInf</code>: Okay, probably the maximum cost assigned before a vertex is discovered.</li>
<li><code>CostZero</code> : Opposite of <code>ConstInf</code> I guess</li>
</ul>

<p>Coming from <code>Qt</code>, <code>boost</code> has one of the horrible documentation to reckon with, it might be that I am looking at the wrong place, but well at least having some color scheme for the code doesn&rsquo;t hurt, if not the broken/missing links. That should be enough for the day.</p>

<h1 id="day-2">Day 2</h1>

<p>Probably the choice I made yesterday of which interface to choose from was wrong, so going with the named parameter interface, today.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#66d9ef">template</span> <span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> VertexListGraph,
          <span style="color:#66d9ef">typename</span> AStarHeuristic,
          <span style="color:#66d9ef">typename</span> P, <span style="color:#66d9ef">typename</span> T, <span style="color:#66d9ef">typename</span> R<span style="color:#f92672">&gt;</span>
<span style="color:#66d9ef">void</span>
astar_search
  (<span style="color:#66d9ef">const</span> VertexListGraph <span style="color:#f92672">&amp;</span>g,
   <span style="color:#66d9ef">typename</span> graph_traits<span style="color:#f92672">&lt;</span>VertexListGraph<span style="color:#f92672">&gt;::</span>vertex_descriptor s,
   AStarHeuristic h, <span style="color:#66d9ef">const</span> bgl_named_params<span style="color:#f92672">&lt;</span>P, T, R<span style="color:#f92672">&gt;&amp;</span> params);
</code></pre></div>
<p>What is the that <code>bgl_named_params&lt;P, T, R&gt;</code> ? A little bit of toing and froing around the web, I found out the docs, voila, guess what, it is just template magic, here is an example from the docs.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#66d9ef">bool</span> r <span style="color:#f92672">=</span> boost<span style="color:#f92672">::</span>bellman_ford_shortest_paths(g, <span style="color:#66d9ef">int</span>(N), 
    boost<span style="color:#f92672">::</span>weight_map(weight). <span style="color:#75715e">//Notice the period
</span><span style="color:#75715e"></span>    distance_map(<span style="color:#f92672">&amp;</span>distance[<span style="color:#ae81ff">0</span>]). <span style="color:#75715e">//It is here too
</span><span style="color:#75715e"></span>    predecessor_map(<span style="color:#f92672">&amp;</span>parent[<span style="color:#ae81ff">0</span>]));
</code></pre></div>
<p>Not enough to deduce what should I put into the <code>boost::astar_search</code>, probably have to look at an example of <code>boost::astar_search</code>. I hope whatever the search engine has pointed me to as an <a href="https://www.boost.org/doc/libs/1_70_0/libs/graph/example/astar_maze.cpp">example</a>, is up-to-date with the latest versions.</p>

<p>The most important part of that example is the call to the <code>boost::astar_search</code> function,</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++">astar_search(m_barrier_grid, s, heuristic,
    boost<span style="color:#f92672">::</span>weight_map(weight).
    predecessor_map(pred_pmap).
    distance_map(dist_pmap).
    visitor(visitor) );
</code></pre></div>
<p>What do those arguments mean?, lets follow the symbols,</p>

<h3 id="boost-weight-map-weight">boost::weight_map(weight)</h3>

<p>Okay, following the variable <code>weight</code>, it is declared like,</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++">boost<span style="color:#f92672">::</span>static_property_map<span style="color:#f92672">&lt;</span>distance<span style="color:#f92672">&gt;</span> weight(<span style="color:#ae81ff">1</span>);
</code></pre></div>
<p>Trusting every ounce of the <code>boost</code> documentation, <code>boost::static_property_map</code> says, &ldquo;<strong>This property map wraps a copy of some particular object, and returns a copy of that object whenever a key object is input</strong>&rdquo;, thats easy, no fancy mutation magic of course. And that distance type is just a facade,</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">double</span> distance;
</code></pre></div>
<h3 id="predecessor-map-pred-pmap">predecessor_map(pred_pmap)</h3>

<p>Following <code>pred_pmap</code>,</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#66d9ef">typedef</span> boost<span style="color:#f92672">::</span>unordered_map<span style="color:#f92672">&lt;</span>vertex_descriptor,
                               vertex_descriptor,
                               vertex_hash<span style="color:#f92672">&gt;</span> pred_map;
pred_map predecessor;
boost<span style="color:#f92672">::</span>associative_property_map<span style="color:#f92672">&lt;</span>pred_map<span style="color:#f92672">&gt;</span> pred_pmap(predecessor);
</code></pre></div>
<p><img src="https://hellozee.github.io/img/boost-confusion.jpg" alt="boost-confusion" /></p>

<p>Documentation of <code>boost::associative_property_map</code> please,</p>

<p>&ldquo;<strong>This property map is an adaptor that converts any type that is a model of both Pair Associative Container and Unique Associative Container such as std::map into a mutable Lvalue Property Map. Note that the adaptor only retains a reference to the container, so the lifetime of the container must encompass the use of the adaptor.</strong>&ldquo;</p>

<p>Okay, in short mutation magic for maps, which we can see as it takes in a <code>boost::unordered_map</code> and maps a vertex to another vertex, and that <code>vertex_hash</code> is just a hash function for the vertices,</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#66d9ef">struct</span> vertex_hash:std<span style="color:#f92672">::</span>unary_function<span style="color:#f92672">&lt;</span>vertex_descriptor, std<span style="color:#f92672">::</span>size_t<span style="color:#f92672">&gt;</span> {
  std<span style="color:#f92672">::</span>size_t <span style="color:#66d9ef">operator</span>()(vertex_descriptor <span style="color:#66d9ef">const</span><span style="color:#f92672">&amp;</span> u) <span style="color:#66d9ef">const</span> {
    std<span style="color:#f92672">::</span>size_t seed <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
    boost<span style="color:#f92672">::</span>hash_combine(seed, u[<span style="color:#ae81ff">0</span>]);
    boost<span style="color:#f92672">::</span>hash_combine(seed, u[<span style="color:#ae81ff">1</span>]);
    <span style="color:#66d9ef">return</span> seed;
  }
};
</code></pre></div>
<h3 id="distance-map-dist-pmap">distance_map(dist_pmap)</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#66d9ef">typedef</span> boost<span style="color:#f92672">::</span>unordered_map<span style="color:#f92672">&lt;</span>vertex_descriptor,
                             distance,
                             vertex_hash<span style="color:#f92672">&gt;</span> dist_map;
dist_map distance;
boost<span style="color:#f92672">::</span>associative_property_map<span style="color:#f92672">&lt;</span>dist_map<span style="color:#f92672">&gt;</span> dist_pmap(distance);
</code></pre></div>
<p>Similar to the previous one, but this time instead of mapping to vertices to other vertices, it is now mapping distance to vertices, easy-peasy.</p>

<h3 id="visitor-visitor">visitor(visitor)</h3>

<p>Something new, following <code>visitor</code>, we get</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++">astar_goal_visitor <span style="color:#a6e22e">visitor</span>(g);
</code></pre></div>
<p>What is that <code>astar_goal_visitor</code> ?</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#66d9ef">struct</span> astar_goal_visitor:<span style="color:#66d9ef">public</span> boost<span style="color:#f92672">::</span>default_astar_visitor {
  astar_goal_visitor(vertex_descriptor goal)<span style="color:#f92672">:</span>m_goal(goal) {};

  <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">examine_vertex</span>(vertex_descriptor u, <span style="color:#66d9ef">const</span> filtered_grid<span style="color:#f92672">&amp;</span>) {
    <span style="color:#66d9ef">if</span> (u <span style="color:#f92672">==</span> m_goal)
      <span style="color:#66d9ef">throw</span> found_goal();
  }

<span style="color:#66d9ef">private</span><span style="color:#f92672">:</span>
  vertex_descriptor m_goal;
};
</code></pre></div>
<p>Ahh it just throws an exception whenever it finds the goal, okay, nothing much interesting here and <code>g</code> is the goal or the final vertex.</p>

<p>I would say I am a little bit confident now, but there are chances that I am going in the wrong direction, with that being said, I think it should be enough for Day 2.</p>

<h1 id="day-3">Day 3</h1>

<p>Last day, I dissected the <code>bgl_name_params</code>, today, one more interesting thing to dissect will be the heuristic function, which would be used to have a guess on which vertex is nearer to the goal and perform a better search.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++">astar_search(m_barrier_grid, s, heuristic,
    boost<span style="color:#f92672">::</span>weight_map(weight).
    predecessor_map(pred_pmap).
    distance_map(dist_pmap).
    visitor(visitor) );
</code></pre></div>
<h3 id="heuristic">heuristic</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++">euclidean_heuristic <span style="color:#a6e22e">heuristic</span>(g);
</code></pre></div>
<p>And then,</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">euclidean_heuristic</span><span style="color:#f92672">:</span>
      <span style="color:#66d9ef">public</span> boost<span style="color:#f92672">::</span>astar_heuristic<span style="color:#f92672">&lt;</span>filtered_grid, <span style="color:#66d9ef">double</span><span style="color:#f92672">&gt;</span>
{
<span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
  euclidean_heuristic(vertex_descriptor goal)<span style="color:#f92672">:</span>m_goal(goal) {};

  <span style="color:#66d9ef">double</span> <span style="color:#a6e22e">operator</span>()(vertex_descriptor v) {
    <span style="color:#66d9ef">return</span> sqrt(pow(<span style="color:#66d9ef">double</span>(m_goal[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">-</span> v[<span style="color:#ae81ff">0</span>]), <span style="color:#ae81ff">2</span>) <span style="color:#f92672">+</span> pow(<span style="color:#66d9ef">double</span>(m_goal[<span style="color:#ae81ff">1</span>] <span style="color:#f92672">-</span> v[<span style="color:#ae81ff">1</span>]), <span style="color:#ae81ff">2</span>));
  }

<span style="color:#66d9ef">private</span><span style="color:#f92672">:</span>
  vertex_descriptor m_goal;
};
</code></pre></div>
<p>First lets take a look at my proposed heuristic function,
<img src="https://hellozee.github.io/img/heuristic1.png" alt="heuristic1" />
The m-suffixed variables are part of the final point, while the 0-suffixed one is for the previous point and the i-suffixed ones are of the current point. Calculates the deviation from the base line.
<img src="https://hellozee.github.io/img/heuristic2.png" alt="heuristic2" />
Simple euclidean distance from the final point.
<img src="https://hellozee.github.io/img/heuristic3.png" alt="heuristic3" />
This one combines them both, with coefficients a and b, which is to be determined experimentally.
Now that I think of it, we can further improove the equation by subtracting the distance of the previous point from the goal from dm, ending up with something like,
<img src="https://hellozee.github.io/img/heuristic4.png" alt="heuristic4" /></p>

<p>I would be needing the previous vertex, the final vertex and the current vertex. The final and the current are obvious from the example, but not sure about the previous one. My wild guess, I should be using the <code>predecessor_map</code> and be done with it. Now if I modify the example function for the above equations,</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">euclidean_heuristic</span><span style="color:#f92672">:</span>
      <span style="color:#66d9ef">public</span> boost<span style="color:#f92672">::</span>astar_heuristic<span style="color:#f92672">&lt;</span>filtered_grid, <span style="color:#66d9ef">double</span><span style="color:#f92672">&gt;</span>
{
<span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
  euclidean_heuristic(vertex_descriptor goal, 
                      boost<span style="color:#f92672">::</span>associative_property_map<span style="color:#f92672">&lt;</span>pred_map<span style="color:#f92672">&gt;</span> pmap)<span style="color:#f92672">:</span>
          m_goal(goal), m_pmap(pmap), a(<span style="color:#ae81ff">0.5</span>), b(<span style="color:#ae81ff">0.5</span>) <span style="color:#75715e">//experimental
</span><span style="color:#75715e"></span>          { }

  <span style="color:#66d9ef">double</span> <span style="color:#66d9ef">operator</span>()(vertex_descriptor v) {
    <span style="color:#66d9ef">auto</span> prev <span style="color:#f92672">=</span> m_pmap[v];
    <span style="color:#66d9ef">auto</span> di <span style="color:#f92672">=</span> (m_goal[<span style="color:#ae81ff">1</span>] <span style="color:#f92672">-</span> prev[<span style="color:#ae81ff">1</span>]) <span style="color:#f92672">*</span> v[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">+</span> (m_goal[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">-</span> prev[<span style="color:#ae81ff">0</span>]) <span style="color:#f92672">*</span> v[<span style="color:#ae81ff">1</span>];
    di <span style="color:#f92672">=</span> std<span style="color:#f92672">::</span>abs(di <span style="color:#f92672">+</span> prev[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">*</span> m_goal[<span style="color:#ae81ff">1</span>] <span style="color:#f92672">+</span> prev[<span style="color:#ae81ff">1</span>] <span style="color:#f92672">*</span> m_goal[<span style="color:#ae81ff">0</span>]);
    <span style="color:#66d9ef">auto</span> dz <span style="color:#f92672">=</span> std<span style="color:#f92672">::</span>sqrt(std<span style="color:#f92672">::</span>pow(m_goal[<span style="color:#ae81ff">1</span>]<span style="color:#f92672">-</span>pred[<span style="color:#ae81ff">1</span>],<span style="color:#ae81ff">2</span>)<span style="color:#f92672">+</span>std<span style="color:#f92672">::</span>pow(m_goal[<span style="color:#ae81ff">0</span>]<span style="color:#f92672">-</span>pred[<span style="color:#ae81ff">0</span>],<span style="color:#ae81ff">2</span>));
    di <span style="color:#f92672">=</span> di<span style="color:#f92672">/</span>dz;
    <span style="color:#66d9ef">auto</span> dm <span style="color:#f92672">=</span> std<span style="color:#f92672">::</span>sqrt(std<span style="color:#f92672">::</span>pow(m_goal[<span style="color:#ae81ff">1</span>]<span style="color:#f92672">-</span>v[<span style="color:#ae81ff">1</span>],<span style="color:#ae81ff">2</span>)<span style="color:#f92672">+</span>std<span style="color:#f92672">::</span>pow(m_goal[<span style="color:#ae81ff">0</span>]<span style="color:#f92672">-</span>v[<span style="color:#ae81ff">0</span>],<span style="color:#ae81ff">2</span>));
    
    <span style="color:#66d9ef">return</span> a <span style="color:#f92672">*</span> di <span style="color:#f92672">+</span> b <span style="color:#f92672">*</span> (dm <span style="color:#f92672">-</span> dz);
  }

<span style="color:#66d9ef">private</span><span style="color:#f92672">:</span>
  vertex_descriptor m_goal;
  boost<span style="color:#f92672">::</span>associative_property_map<span style="color:#f92672">&lt;</span>pred_map<span style="color:#f92672">&gt;</span> m_pmap;
  <span style="color:#66d9ef">double</span> a,b;
};
</code></pre></div>
<p>That should be enough for now, probably I can implement simply like this, but it surely requires some more research, which would be for some other blogpost. So, it is a <code>:wq</code> for today.</p>


</article>


<section class="post-nav">
    <ul>
        
        <li>
            <a href="https://hellozee.github.io/posts/linux-desktop/"><i class="fa fa-chevron-circle-left"></i> This is the year of Linux Desktop</a>
        </li>
        
        
        <li>
            <a href="https://hellozee.github.io/posts/another_week_with_boost/">Another Week with boost::graph <i class="fa fa-chevron-circle-right"></i> </a>
        </li>
        
    </ul>
</section>
    
        <section class="comments-block">
      <button id="show-comments" style="display: none;"><i class="fa fa-comments-o"></i> Add/View Comments</button>
</section>

<section id="disqus_thread"></section>

<script>
      (function () {
            
            
            if (window.location.hostname == "localhost")
                  return;

            var disqus_loaded = false;
            var disqus_shortname = 'hellozee-me';
            var disqus_button = document.getElementById("show-comments");

            disqus_button.style.display = "";
            disqus_button.addEventListener("click", disqus, false);

            function disqus() {

                  if (!disqus_loaded) {
                        disqus_loaded = true;

                        var e = document.createElement("script");
                        e.type = "text/javascript";
                        e.async = true;
                        e.src = "//" + disqus_shortname + ".disqus.com/embed.js";
                        (document.getElementsByTagName("head")[0] ||
                              document.getElementsByTagName("body")[0])
                        .appendChild(e);

                        
                        document.getElementById("show-comments").style.display = "none";
                  }
            }

            
            var hash = window.location.hash.substr(1);
            if (hash.length > 8) {
                  if (hash.substring(0, 8) == "comment-") {
                        disqus();
                  }
            }

            
            if (/bot|google|baidu|bing|msn|duckduckgo|slurp|yandex/i.test(navigator.userAgent)) {
                  disqus();
            }
      })();
</script>
    





</main>
    <footer>
        <h6>Copyright &copy; 2019 - Kuntal Majumder | 
            Rendered by <a href="https://gohugo.io" title="Hugo">Hugo</a> |
            <a href="https://hellozee.github.io/index.xml">Subscribe</a></h6>
    </footer>
</div>
<script src="https://hellozee.github.io/js/scripts.js"></script>
</body>

</html>
